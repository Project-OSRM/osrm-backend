// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ROUTE_OSRM_ENGINE_API_FBRESULT_H_
#define FLATBUFFERS_GENERATED_ROUTE_OSRM_ENGINE_API_FBRESULT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "waypoint_generated.h"

namespace osrm {
namespace engine {
namespace api {
namespace fbresult {

struct Metadata;
struct MetadataBuilder;

struct Annotation;
struct AnnotationBuilder;

struct StepManeuver;
struct StepManeuverBuilder;

struct Lane;
struct LaneBuilder;

struct Intersection;
struct IntersectionBuilder;

struct Step;
struct StepBuilder;

struct Leg;
struct LegBuilder;

struct RouteObject;
struct RouteObjectBuilder;

enum ManeuverType : int8_t {
  ManeuverType_Turn = 0,
  ManeuverType_NewName = 1,
  ManeuverType_Depart = 2,
  ManeuverType_Arrive = 3,
  ManeuverType_Merge = 4,
  ManeuverType_OnRamp = 5,
  ManeuverType_OffRamp = 6,
  ManeuverType_Fork = 7,
  ManeuverType_EndOfRoad = 8,
  ManeuverType_Continue = 9,
  ManeuverType_Roundabout = 10,
  ManeuverType_Rotary = 11,
  ManeuverType_RoundaboutTurn = 12,
  ManeuverType_Notification = 13,
  ManeuverType_ExitRoundabout = 14,
  ManeuverType_ExitRotary = 15,
  ManeuverType_MIN = ManeuverType_Turn,
  ManeuverType_MAX = ManeuverType_ExitRotary
};

inline const ManeuverType (&EnumValuesManeuverType())[16] {
  static const ManeuverType values[] = {
    ManeuverType_Turn,
    ManeuverType_NewName,
    ManeuverType_Depart,
    ManeuverType_Arrive,
    ManeuverType_Merge,
    ManeuverType_OnRamp,
    ManeuverType_OffRamp,
    ManeuverType_Fork,
    ManeuverType_EndOfRoad,
    ManeuverType_Continue,
    ManeuverType_Roundabout,
    ManeuverType_Rotary,
    ManeuverType_RoundaboutTurn,
    ManeuverType_Notification,
    ManeuverType_ExitRoundabout,
    ManeuverType_ExitRotary
  };
  return values;
}

inline const char * const *EnumNamesManeuverType() {
  static const char * const names[17] = {
    "Turn",
    "NewName",
    "Depart",
    "Arrive",
    "Merge",
    "OnRamp",
    "OffRamp",
    "Fork",
    "EndOfRoad",
    "Continue",
    "Roundabout",
    "Rotary",
    "RoundaboutTurn",
    "Notification",
    "ExitRoundabout",
    "ExitRotary",
    nullptr
  };
  return names;
}

inline const char *EnumNameManeuverType(ManeuverType e) {
  if (::flatbuffers::IsOutRange(e, ManeuverType_Turn, ManeuverType_ExitRotary)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesManeuverType()[index];
}

enum Turn : int8_t {
  Turn_None = 0,
  Turn_UTurn = 1,
  Turn_SharpRight = 2,
  Turn_Right = 3,
  Turn_SlightRight = 4,
  Turn_Straight = 5,
  Turn_SlightLeft = 6,
  Turn_Left = 7,
  Turn_SharpLeft = 8,
  Turn_MIN = Turn_None,
  Turn_MAX = Turn_SharpLeft
};

inline const Turn (&EnumValuesTurn())[9] {
  static const Turn values[] = {
    Turn_None,
    Turn_UTurn,
    Turn_SharpRight,
    Turn_Right,
    Turn_SlightRight,
    Turn_Straight,
    Turn_SlightLeft,
    Turn_Left,
    Turn_SharpLeft
  };
  return values;
}

inline const char * const *EnumNamesTurn() {
  static const char * const names[10] = {
    "None",
    "UTurn",
    "SharpRight",
    "Right",
    "SlightRight",
    "Straight",
    "SlightLeft",
    "Left",
    "SharpLeft",
    nullptr
  };
  return names;
}

inline const char *EnumNameTurn(Turn e) {
  if (::flatbuffers::IsOutRange(e, Turn_None, Turn_SharpLeft)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTurn()[index];
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATASOURCE_NAMES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *datasource_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATASOURCE_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATASOURCE_NAMES) &&
           verifier.VerifyVector(datasource_names()) &&
           verifier.VerifyVectorOfStrings(datasource_names()) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_datasource_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> datasource_names) {
    fbb_.AddOffset(Metadata::VT_DATASOURCE_NAMES, datasource_names);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> datasource_names = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_datasource_names(datasource_names);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *datasource_names = nullptr) {
  auto datasource_names__ = datasource_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*datasource_names) : 0;
  return osrm::engine::api::fbresult::CreateMetadata(
      _fbb,
      datasource_names__);
}

struct Annotation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_DATASOURCES = 8,
    VT_NODES = 10,
    VT_WEIGHT = 12,
    VT_SPEED = 14,
    VT_METADATA = 16
  };
  const ::flatbuffers::Vector<uint32_t> *distance() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DISTANCE);
  }
  const ::flatbuffers::Vector<uint32_t> *duration() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DURATION);
  }
  const ::flatbuffers::Vector<uint32_t> *datasources() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DATASOURCES);
  }
  const ::flatbuffers::Vector<uint32_t> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<uint32_t> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<float> *speed() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SPEED);
  }
  const osrm::engine::api::fbresult::Metadata *metadata() const {
    return GetPointer<const osrm::engine::api::fbresult::Metadata *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISTANCE) &&
           verifier.VerifyVector(distance()) &&
           VerifyOffset(verifier, VT_DURATION) &&
           verifier.VerifyVector(duration()) &&
           VerifyOffset(verifier, VT_DATASOURCES) &&
           verifier.VerifyVector(datasources()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyVector(speed()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           verifier.EndTable();
  }
};

struct AnnotationBuilder {
  typedef Annotation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_distance(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> distance) {
    fbb_.AddOffset(Annotation::VT_DISTANCE, distance);
  }
  void add_duration(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> duration) {
    fbb_.AddOffset(Annotation::VT_DURATION, duration);
  }
  void add_datasources(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> datasources) {
    fbb_.AddOffset(Annotation::VT_DATASOURCES, datasources);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> nodes) {
    fbb_.AddOffset(Annotation::VT_NODES, nodes);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> weight) {
    fbb_.AddOffset(Annotation::VT_WEIGHT, weight);
  }
  void add_speed(::flatbuffers::Offset<::flatbuffers::Vector<float>> speed) {
    fbb_.AddOffset(Annotation::VT_SPEED, speed);
  }
  void add_metadata(::flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata) {
    fbb_.AddOffset(Annotation::VT_METADATA, metadata);
  }
  explicit AnnotationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Annotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Annotation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Annotation> CreateAnnotation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> distance = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> duration = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> datasources = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> speed = 0,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata = 0) {
  AnnotationBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_speed(speed);
  builder_.add_weight(weight);
  builder_.add_nodes(nodes);
  builder_.add_datasources(datasources);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Annotation> CreateAnnotationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *distance = nullptr,
    const std::vector<uint32_t> *duration = nullptr,
    const std::vector<uint32_t> *datasources = nullptr,
    const std::vector<uint32_t> *nodes = nullptr,
    const std::vector<uint32_t> *weight = nullptr,
    const std::vector<float> *speed = nullptr,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::Metadata> metadata = 0) {
  auto distance__ = distance ? _fbb.CreateVector<uint32_t>(*distance) : 0;
  auto duration__ = duration ? _fbb.CreateVector<uint32_t>(*duration) : 0;
  auto datasources__ = datasources ? _fbb.CreateVector<uint32_t>(*datasources) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<uint32_t>(*nodes) : 0;
  auto weight__ = weight ? _fbb.CreateVector<uint32_t>(*weight) : 0;
  auto speed__ = speed ? _fbb.CreateVector<float>(*speed) : 0;
  return osrm::engine::api::fbresult::CreateAnnotation(
      _fbb,
      distance__,
      duration__,
      datasources__,
      nodes__,
      weight__,
      speed__,
      metadata);
}

struct StepManeuver FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StepManeuverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_BEARING_BEFORE = 6,
    VT_BEARING_AFTER = 8,
    VT_TYPE = 10,
    VT_MODIFIER = 12,
    VT_EXIT = 14
  };
  const osrm::engine::api::fbresult::Position *location() const {
    return GetStruct<const osrm::engine::api::fbresult::Position *>(VT_LOCATION);
  }
  uint16_t bearing_before() const {
    return GetField<uint16_t>(VT_BEARING_BEFORE, 0);
  }
  uint16_t bearing_after() const {
    return GetField<uint16_t>(VT_BEARING_AFTER, 0);
  }
  osrm::engine::api::fbresult::ManeuverType type() const {
    return static_cast<osrm::engine::api::fbresult::ManeuverType>(GetField<int8_t>(VT_TYPE, 0));
  }
  osrm::engine::api::fbresult::Turn modifier() const {
    return static_cast<osrm::engine::api::fbresult::Turn>(GetField<int8_t>(VT_MODIFIER, 0));
  }
  uint8_t exit() const {
    return GetField<uint8_t>(VT_EXIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<osrm::engine::api::fbresult::Position>(verifier, VT_LOCATION, 4) &&
           VerifyField<uint16_t>(verifier, VT_BEARING_BEFORE, 2) &&
           VerifyField<uint16_t>(verifier, VT_BEARING_AFTER, 2) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_MODIFIER, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXIT, 1) &&
           verifier.EndTable();
  }
};

struct StepManeuverBuilder {
  typedef StepManeuver Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_location(const osrm::engine::api::fbresult::Position *location) {
    fbb_.AddStruct(StepManeuver::VT_LOCATION, location);
  }
  void add_bearing_before(uint16_t bearing_before) {
    fbb_.AddElement<uint16_t>(StepManeuver::VT_BEARING_BEFORE, bearing_before, 0);
  }
  void add_bearing_after(uint16_t bearing_after) {
    fbb_.AddElement<uint16_t>(StepManeuver::VT_BEARING_AFTER, bearing_after, 0);
  }
  void add_type(osrm::engine::api::fbresult::ManeuverType type) {
    fbb_.AddElement<int8_t>(StepManeuver::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_modifier(osrm::engine::api::fbresult::Turn modifier) {
    fbb_.AddElement<int8_t>(StepManeuver::VT_MODIFIER, static_cast<int8_t>(modifier), 0);
  }
  void add_exit(uint8_t exit) {
    fbb_.AddElement<uint8_t>(StepManeuver::VT_EXIT, exit, 0);
  }
  explicit StepManeuverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StepManeuver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StepManeuver>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StepManeuver> CreateStepManeuver(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const osrm::engine::api::fbresult::Position *location = nullptr,
    uint16_t bearing_before = 0,
    uint16_t bearing_after = 0,
    osrm::engine::api::fbresult::ManeuverType type = osrm::engine::api::fbresult::ManeuverType_Turn,
    osrm::engine::api::fbresult::Turn modifier = osrm::engine::api::fbresult::Turn_None,
    uint8_t exit = 0) {
  StepManeuverBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_bearing_after(bearing_after);
  builder_.add_bearing_before(bearing_before);
  builder_.add_exit(exit);
  builder_.add_modifier(modifier);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Lane FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LaneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICATIONS = 4,
    VT_VALID = 6
  };
  const ::flatbuffers::Vector<int8_t> *indications() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_INDICATIONS);
  }
  bool valid() const {
    return GetField<uint8_t>(VT_VALID, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICATIONS) &&
           verifier.VerifyVector(indications()) &&
           VerifyField<uint8_t>(verifier, VT_VALID, 1) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  typedef Lane Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_indications(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> indications) {
    fbb_.AddOffset(Lane::VT_INDICATIONS, indications);
  }
  void add_valid(bool valid) {
    fbb_.AddElement<uint8_t>(Lane::VT_VALID, static_cast<uint8_t>(valid), 0);
  }
  explicit LaneBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Lane> CreateLane(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> indications = 0,
    bool valid = false) {
  LaneBuilder builder_(_fbb);
  builder_.add_indications(indications);
  builder_.add_valid(valid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Lane> CreateLaneDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *indications = nullptr,
    bool valid = false) {
  auto indications__ = indications ? _fbb.CreateVector<int8_t>(*indications) : 0;
  return osrm::engine::api::fbresult::CreateLane(
      _fbb,
      indications__,
      valid);
}

struct Intersection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntersectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION = 4,
    VT_BEARINGS = 6,
    VT_CLASSES = 8,
    VT_ENTRY = 10,
    VT_IN_BEARING = 12,
    VT_OUT_BEARING = 14,
    VT_LANES = 16
  };
  const osrm::engine::api::fbresult::Position *location() const {
    return GetStruct<const osrm::engine::api::fbresult::Position *>(VT_LOCATION);
  }
  const ::flatbuffers::Vector<int16_t> *bearings() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_BEARINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *classes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CLASSES);
  }
  const ::flatbuffers::Vector<uint8_t> *entry() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ENTRY);
  }
  uint32_t in_bearing() const {
    return GetField<uint32_t>(VT_IN_BEARING, 0);
  }
  uint32_t out_bearing() const {
    return GetField<uint32_t>(VT_OUT_BEARING, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *lanes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *>(VT_LANES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<osrm::engine::api::fbresult::Position>(verifier, VT_LOCATION, 4) &&
           VerifyOffset(verifier, VT_BEARINGS) &&
           verifier.VerifyVector(bearings()) &&
           VerifyOffset(verifier, VT_CLASSES) &&
           verifier.VerifyVector(classes()) &&
           verifier.VerifyVectorOfStrings(classes()) &&
           VerifyOffset(verifier, VT_ENTRY) &&
           verifier.VerifyVector(entry()) &&
           VerifyField<uint32_t>(verifier, VT_IN_BEARING, 4) &&
           VerifyField<uint32_t>(verifier, VT_OUT_BEARING, 4) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct IntersectionBuilder {
  typedef Intersection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_location(const osrm::engine::api::fbresult::Position *location) {
    fbb_.AddStruct(Intersection::VT_LOCATION, location);
  }
  void add_bearings(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> bearings) {
    fbb_.AddOffset(Intersection::VT_BEARINGS, bearings);
  }
  void add_classes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> classes) {
    fbb_.AddOffset(Intersection::VT_CLASSES, classes);
  }
  void add_entry(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> entry) {
    fbb_.AddOffset(Intersection::VT_ENTRY, entry);
  }
  void add_in_bearing(uint32_t in_bearing) {
    fbb_.AddElement<uint32_t>(Intersection::VT_IN_BEARING, in_bearing, 0);
  }
  void add_out_bearing(uint32_t out_bearing) {
    fbb_.AddElement<uint32_t>(Intersection::VT_OUT_BEARING, out_bearing, 0);
  }
  void add_lanes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>> lanes) {
    fbb_.AddOffset(Intersection::VT_LANES, lanes);
  }
  explicit IntersectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Intersection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Intersection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Intersection> CreateIntersection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const osrm::engine::api::fbresult::Position *location = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> bearings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> classes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> entry = 0,
    uint32_t in_bearing = 0,
    uint32_t out_bearing = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>> lanes = 0) {
  IntersectionBuilder builder_(_fbb);
  builder_.add_lanes(lanes);
  builder_.add_out_bearing(out_bearing);
  builder_.add_in_bearing(in_bearing);
  builder_.add_entry(entry);
  builder_.add_classes(classes);
  builder_.add_bearings(bearings);
  builder_.add_location(location);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Intersection> CreateIntersectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const osrm::engine::api::fbresult::Position *location = nullptr,
    const std::vector<int16_t> *bearings = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *classes = nullptr,
    const std::vector<uint8_t> *entry = nullptr,
    uint32_t in_bearing = 0,
    uint32_t out_bearing = 0,
    const std::vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>> *lanes = nullptr) {
  auto bearings__ = bearings ? _fbb.CreateVector<int16_t>(*bearings) : 0;
  auto classes__ = classes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*classes) : 0;
  auto entry__ = entry ? _fbb.CreateVector<uint8_t>(*entry) : 0;
  auto lanes__ = lanes ? _fbb.CreateVector<::flatbuffers::Offset<osrm::engine::api::fbresult::Lane>>(*lanes) : 0;
  return osrm::engine::api::fbresult::CreateIntersection(
      _fbb,
      location,
      bearings__,
      classes__,
      entry__,
      in_bearing,
      out_bearing,
      lanes__);
}

struct Step FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_POLYLINE = 8,
    VT_COORDINATES = 10,
    VT_WEIGHT = 12,
    VT_NAME = 14,
    VT_REF = 16,
    VT_PRONUNCIATION = 18,
    VT_DESTINATIONS = 20,
    VT_EXITS = 22,
    VT_MODE = 24,
    VT_MANEUVER = 26,
    VT_INTERSECTIONS = 28,
    VT_ROTARY_NAME = 30,
    VT_ROTARY_PRONUNCIATION = 32,
    VT_DRIVING_SIDE = 34
  };
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 0.0f);
  }
  const ::flatbuffers::String *polyline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POLYLINE);
  }
  const ::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *> *coordinates() const {
    return GetPointer<const ::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *> *>(VT_COORDINATES);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *ref() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF);
  }
  const ::flatbuffers::String *pronunciation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRONUNCIATION);
  }
  const ::flatbuffers::String *destinations() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESTINATIONS);
  }
  const ::flatbuffers::String *exits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXITS);
  }
  const ::flatbuffers::String *mode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  const osrm::engine::api::fbresult::StepManeuver *maneuver() const {
    return GetPointer<const osrm::engine::api::fbresult::StepManeuver *>(VT_MANEUVER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *intersections() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *>(VT_INTERSECTIONS);
  }
  const ::flatbuffers::String *rotary_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROTARY_NAME);
  }
  const ::flatbuffers::String *rotary_pronunciation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROTARY_PRONUNCIATION);
  }
  bool driving_side() const {
    return GetField<uint8_t>(VT_DRIVING_SIDE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           VerifyField<float>(verifier, VT_DURATION, 4) &&
           VerifyOffset(verifier, VT_POLYLINE) &&
           verifier.VerifyString(polyline()) &&
           VerifyOffset(verifier, VT_COORDINATES) &&
           verifier.VerifyVector(coordinates()) &&
           VerifyField<float>(verifier, VT_WEIGHT, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REF) &&
           verifier.VerifyString(ref()) &&
           VerifyOffset(verifier, VT_PRONUNCIATION) &&
           verifier.VerifyString(pronunciation()) &&
           VerifyOffset(verifier, VT_DESTINATIONS) &&
           verifier.VerifyString(destinations()) &&
           VerifyOffset(verifier, VT_EXITS) &&
           verifier.VerifyString(exits()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_MANEUVER) &&
           verifier.VerifyTable(maneuver()) &&
           VerifyOffset(verifier, VT_INTERSECTIONS) &&
           verifier.VerifyVector(intersections()) &&
           verifier.VerifyVectorOfTables(intersections()) &&
           VerifyOffset(verifier, VT_ROTARY_NAME) &&
           verifier.VerifyString(rotary_name()) &&
           VerifyOffset(verifier, VT_ROTARY_PRONUNCIATION) &&
           verifier.VerifyString(rotary_pronunciation()) &&
           VerifyField<uint8_t>(verifier, VT_DRIVING_SIDE, 1) &&
           verifier.EndTable();
  }
};

struct StepBuilder {
  typedef Step Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_distance(float distance) {
    fbb_.AddElement<float>(Step::VT_DISTANCE, distance, 0.0f);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(Step::VT_DURATION, duration, 0.0f);
  }
  void add_polyline(::flatbuffers::Offset<::flatbuffers::String> polyline) {
    fbb_.AddOffset(Step::VT_POLYLINE, polyline);
  }
  void add_coordinates(::flatbuffers::Offset<::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *>> coordinates) {
    fbb_.AddOffset(Step::VT_COORDINATES, coordinates);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Step::VT_WEIGHT, weight, 0.0f);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Step::VT_NAME, name);
  }
  void add_ref(::flatbuffers::Offset<::flatbuffers::String> ref) {
    fbb_.AddOffset(Step::VT_REF, ref);
  }
  void add_pronunciation(::flatbuffers::Offset<::flatbuffers::String> pronunciation) {
    fbb_.AddOffset(Step::VT_PRONUNCIATION, pronunciation);
  }
  void add_destinations(::flatbuffers::Offset<::flatbuffers::String> destinations) {
    fbb_.AddOffset(Step::VT_DESTINATIONS, destinations);
  }
  void add_exits(::flatbuffers::Offset<::flatbuffers::String> exits) {
    fbb_.AddOffset(Step::VT_EXITS, exits);
  }
  void add_mode(::flatbuffers::Offset<::flatbuffers::String> mode) {
    fbb_.AddOffset(Step::VT_MODE, mode);
  }
  void add_maneuver(::flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver) {
    fbb_.AddOffset(Step::VT_MANEUVER, maneuver);
  }
  void add_intersections(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>> intersections) {
    fbb_.AddOffset(Step::VT_INTERSECTIONS, intersections);
  }
  void add_rotary_name(::flatbuffers::Offset<::flatbuffers::String> rotary_name) {
    fbb_.AddOffset(Step::VT_ROTARY_NAME, rotary_name);
  }
  void add_rotary_pronunciation(::flatbuffers::Offset<::flatbuffers::String> rotary_pronunciation) {
    fbb_.AddOffset(Step::VT_ROTARY_PRONUNCIATION, rotary_pronunciation);
  }
  void add_driving_side(bool driving_side) {
    fbb_.AddElement<uint8_t>(Step::VT_DRIVING_SIDE, static_cast<uint8_t>(driving_side), 0);
  }
  explicit StepBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Step> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Step>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Step> CreateStep(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float distance = 0.0f,
    float duration = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> polyline = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *>> coordinates = 0,
    float weight = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ref = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pronunciation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> destinations = 0,
    ::flatbuffers::Offset<::flatbuffers::String> exits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mode = 0,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>> intersections = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rotary_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rotary_pronunciation = 0,
    bool driving_side = false) {
  StepBuilder builder_(_fbb);
  builder_.add_rotary_pronunciation(rotary_pronunciation);
  builder_.add_rotary_name(rotary_name);
  builder_.add_intersections(intersections);
  builder_.add_maneuver(maneuver);
  builder_.add_mode(mode);
  builder_.add_exits(exits);
  builder_.add_destinations(destinations);
  builder_.add_pronunciation(pronunciation);
  builder_.add_ref(ref);
  builder_.add_name(name);
  builder_.add_weight(weight);
  builder_.add_coordinates(coordinates);
  builder_.add_polyline(polyline);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  builder_.add_driving_side(driving_side);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Step> CreateStepDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float distance = 0.0f,
    float duration = 0.0f,
    const char *polyline = nullptr,
    const std::vector<osrm::engine::api::fbresult::Position> *coordinates = nullptr,
    float weight = 0.0f,
    const char *name = nullptr,
    const char *ref = nullptr,
    const char *pronunciation = nullptr,
    const char *destinations = nullptr,
    const char *exits = nullptr,
    const char *mode = nullptr,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::StepManeuver> maneuver = 0,
    const std::vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>> *intersections = nullptr,
    const char *rotary_name = nullptr,
    const char *rotary_pronunciation = nullptr,
    bool driving_side = false) {
  auto polyline__ = polyline ? _fbb.CreateString(polyline) : 0;
  auto coordinates__ = coordinates ? _fbb.CreateVectorOfStructs<osrm::engine::api::fbresult::Position>(*coordinates) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto ref__ = ref ? _fbb.CreateString(ref) : 0;
  auto pronunciation__ = pronunciation ? _fbb.CreateString(pronunciation) : 0;
  auto destinations__ = destinations ? _fbb.CreateString(destinations) : 0;
  auto exits__ = exits ? _fbb.CreateString(exits) : 0;
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto intersections__ = intersections ? _fbb.CreateVector<::flatbuffers::Offset<osrm::engine::api::fbresult::Intersection>>(*intersections) : 0;
  auto rotary_name__ = rotary_name ? _fbb.CreateString(rotary_name) : 0;
  auto rotary_pronunciation__ = rotary_pronunciation ? _fbb.CreateString(rotary_pronunciation) : 0;
  return osrm::engine::api::fbresult::CreateStep(
      _fbb,
      distance,
      duration,
      polyline__,
      coordinates__,
      weight,
      name__,
      ref__,
      pronunciation__,
      destinations__,
      exits__,
      mode__,
      maneuver,
      intersections__,
      rotary_name__,
      rotary_pronunciation__,
      driving_side);
}

struct Leg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LegBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_WEIGHT = 8,
    VT_SUMMARY = 10,
    VT_ANNOTATIONS = 12,
    VT_STEPS = 14
  };
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double duration() const {
    return GetField<double>(VT_DURATION, 0.0);
  }
  double weight() const {
    return GetField<double>(VT_WEIGHT, 0.0);
  }
  const ::flatbuffers::String *summary() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUMMARY);
  }
  const osrm::engine::api::fbresult::Annotation *annotations() const {
    return GetPointer<const osrm::engine::api::fbresult::Annotation *>(VT_ANNOTATIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *steps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *>(VT_STEPS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_DISTANCE, 8) &&
           VerifyField<double>(verifier, VT_DURATION, 8) &&
           VerifyField<double>(verifier, VT_WEIGHT, 8) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyString(summary()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           verifier.VerifyVectorOfTables(steps()) &&
           verifier.EndTable();
  }
};

struct LegBuilder {
  typedef Leg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_distance(double distance) {
    fbb_.AddElement<double>(Leg::VT_DISTANCE, distance, 0.0);
  }
  void add_duration(double duration) {
    fbb_.AddElement<double>(Leg::VT_DURATION, duration, 0.0);
  }
  void add_weight(double weight) {
    fbb_.AddElement<double>(Leg::VT_WEIGHT, weight, 0.0);
  }
  void add_summary(::flatbuffers::Offset<::flatbuffers::String> summary) {
    fbb_.AddOffset(Leg::VT_SUMMARY, summary);
  }
  void add_annotations(::flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations) {
    fbb_.AddOffset(Leg::VT_ANNOTATIONS, annotations);
  }
  void add_steps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>>> steps) {
    fbb_.AddOffset(Leg::VT_STEPS, steps);
  }
  explicit LegBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Leg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Leg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Leg> CreateLeg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> summary = 0,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>>> steps = 0) {
  LegBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  builder_.add_steps(steps);
  builder_.add_annotations(annotations);
  builder_.add_summary(summary);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Leg> CreateLegDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double distance = 0.0,
    double duration = 0.0,
    double weight = 0.0,
    const char *summary = nullptr,
    ::flatbuffers::Offset<osrm::engine::api::fbresult::Annotation> annotations = 0,
    const std::vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>> *steps = nullptr) {
  auto summary__ = summary ? _fbb.CreateString(summary) : 0;
  auto steps__ = steps ? _fbb.CreateVector<::flatbuffers::Offset<osrm::engine::api::fbresult::Step>>(*steps) : 0;
  return osrm::engine::api::fbresult::CreateLeg(
      _fbb,
      distance,
      duration,
      weight,
      summary__,
      annotations,
      steps__);
}

struct RouteObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RouteObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISTANCE = 4,
    VT_DURATION = 6,
    VT_WEIGHT = 8,
    VT_WEIGHT_NAME = 10,
    VT_CONFIDENCE = 12,
    VT_POLYLINE = 14,
    VT_COORDINATES = 16,
    VT_LEGS = 18
  };
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 0.0f);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  const ::flatbuffers::String *weight_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEIGHT_NAME);
  }
  float confidence() const {
    return GetField<float>(VT_CONFIDENCE, 0.0f);
  }
  const ::flatbuffers::String *polyline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POLYLINE);
  }
  const ::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *> *coordinates() const {
    return GetPointer<const ::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *> *>(VT_COORDINATES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *legs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *>(VT_LEGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           VerifyField<float>(verifier, VT_DURATION, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT, 4) &&
           VerifyOffset(verifier, VT_WEIGHT_NAME) &&
           verifier.VerifyString(weight_name()) &&
           VerifyField<float>(verifier, VT_CONFIDENCE, 4) &&
           VerifyOffset(verifier, VT_POLYLINE) &&
           verifier.VerifyString(polyline()) &&
           VerifyOffset(verifier, VT_COORDINATES) &&
           verifier.VerifyVector(coordinates()) &&
           VerifyOffset(verifier, VT_LEGS) &&
           verifier.VerifyVector(legs()) &&
           verifier.VerifyVectorOfTables(legs()) &&
           verifier.EndTable();
  }
};

struct RouteObjectBuilder {
  typedef RouteObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_distance(float distance) {
    fbb_.AddElement<float>(RouteObject::VT_DISTANCE, distance, 0.0f);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(RouteObject::VT_DURATION, duration, 0.0f);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(RouteObject::VT_WEIGHT, weight, 0.0f);
  }
  void add_weight_name(::flatbuffers::Offset<::flatbuffers::String> weight_name) {
    fbb_.AddOffset(RouteObject::VT_WEIGHT_NAME, weight_name);
  }
  void add_confidence(float confidence) {
    fbb_.AddElement<float>(RouteObject::VT_CONFIDENCE, confidence, 0.0f);
  }
  void add_polyline(::flatbuffers::Offset<::flatbuffers::String> polyline) {
    fbb_.AddOffset(RouteObject::VT_POLYLINE, polyline);
  }
  void add_coordinates(::flatbuffers::Offset<::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *>> coordinates) {
    fbb_.AddOffset(RouteObject::VT_COORDINATES, coordinates);
  }
  void add_legs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>> legs) {
    fbb_.AddOffset(RouteObject::VT_LEGS, legs);
  }
  explicit RouteObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RouteObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RouteObject>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RouteObject> CreateRouteObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float distance = 0.0f,
    float duration = 0.0f,
    float weight = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> weight_name = 0,
    float confidence = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> polyline = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const osrm::engine::api::fbresult::Position *>> coordinates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>> legs = 0) {
  RouteObjectBuilder builder_(_fbb);
  builder_.add_legs(legs);
  builder_.add_coordinates(coordinates);
  builder_.add_polyline(polyline);
  builder_.add_confidence(confidence);
  builder_.add_weight_name(weight_name);
  builder_.add_weight(weight);
  builder_.add_duration(duration);
  builder_.add_distance(distance);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RouteObject> CreateRouteObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float distance = 0.0f,
    float duration = 0.0f,
    float weight = 0.0f,
    const char *weight_name = nullptr,
    float confidence = 0.0f,
    const char *polyline = nullptr,
    const std::vector<osrm::engine::api::fbresult::Position> *coordinates = nullptr,
    const std::vector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>> *legs = nullptr) {
  auto weight_name__ = weight_name ? _fbb.CreateString(weight_name) : 0;
  auto polyline__ = polyline ? _fbb.CreateString(polyline) : 0;
  auto coordinates__ = coordinates ? _fbb.CreateVectorOfStructs<osrm::engine::api::fbresult::Position>(*coordinates) : 0;
  auto legs__ = legs ? _fbb.CreateVector<::flatbuffers::Offset<osrm::engine::api::fbresult::Leg>>(*legs) : 0;
  return osrm::engine::api::fbresult::CreateRouteObject(
      _fbb,
      distance,
      duration,
      weight,
      weight_name__,
      confidence,
      polyline__,
      coordinates__,
      legs__);
}

}  // namespace fbresult
}  // namespace api
}  // namespace engine
}  // namespace osrm

#endif  // FLATBUFFERS_GENERATED_ROUTE_OSRM_ENGINE_API_FBRESULT_H_
