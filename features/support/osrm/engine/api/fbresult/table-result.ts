// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Waypoint } from '../../../../osrm/engine/api/fbresult/waypoint.js';


export class TableResult {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TableResult {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTableResult(bb:flatbuffers.ByteBuffer, obj?:TableResult):TableResult {
  return (obj || new TableResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTableResult(bb:flatbuffers.ByteBuffer, obj?:TableResult):TableResult {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TableResult()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

durations(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

durationsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

durationsArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

rows():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

cols():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readUint16(this.bb_pos + offset) : 0;
}

distances(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

distancesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

distancesArray():Float32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Float32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

destinations(index: number, obj?:Waypoint):Waypoint|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new Waypoint()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

destinationsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

fallbackSpeedCells(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

fallbackSpeedCellsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

fallbackSpeedCellsArray():Uint32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Uint32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

static startTableResult(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addDurations(builder:flatbuffers.Builder, durationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, durationsOffset, 0);
}

static createDurationsVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createDurationsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createDurationsVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startDurationsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addRows(builder:flatbuffers.Builder, rows:number) {
  builder.addFieldInt16(1, rows, 0);
}

static addCols(builder:flatbuffers.Builder, cols:number) {
  builder.addFieldInt16(2, cols, 0);
}

static addDistances(builder:flatbuffers.Builder, distancesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, distancesOffset, 0);
}

static createDistancesVector(builder:flatbuffers.Builder, data:number[]|Float32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createDistancesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createDistancesVector(builder:flatbuffers.Builder, data:number[]|Float32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat32(data[i]!);
  }
  return builder.endVector();
}

static startDistancesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addDestinations(builder:flatbuffers.Builder, destinationsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, destinationsOffset, 0);
}

static createDestinationsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startDestinationsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addFallbackSpeedCells(builder:flatbuffers.Builder, fallbackSpeedCellsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, fallbackSpeedCellsOffset, 0);
}

static createFallbackSpeedCellsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createFallbackSpeedCellsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createFallbackSpeedCellsVector(builder:flatbuffers.Builder, data:number[]|Uint32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]!);
  }
  return builder.endVector();
}

static startFallbackSpeedCellsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endTableResult(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createTableResult(builder:flatbuffers.Builder, durationsOffset:flatbuffers.Offset, rows:number, cols:number, distancesOffset:flatbuffers.Offset, destinationsOffset:flatbuffers.Offset, fallbackSpeedCellsOffset:flatbuffers.Offset):flatbuffers.Offset {
  TableResult.startTableResult(builder);
  TableResult.addDurations(builder, durationsOffset);
  TableResult.addRows(builder, rows);
  TableResult.addCols(builder, cols);
  TableResult.addDistances(builder, distancesOffset);
  TableResult.addDestinations(builder, destinationsOffset);
  TableResult.addFallbackSpeedCells(builder, fallbackSpeedCellsOffset);
  return TableResult.endTableResult(builder);
}
}
