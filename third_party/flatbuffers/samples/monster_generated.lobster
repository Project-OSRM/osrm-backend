// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

namespace MyGame_Sample

enum Color:
    Color_Red = 0
    Color_Green = 1
    Color_Blue = 2

enum Equipment:
    Equipment_NONE = 0
    Equipment_Weapon = 1

class Vec3

class Monster

class Weapon

class Vec3 : flatbuffers_handle
    def x():
        return buf_.read_float32_le(pos_ + 0)
    def y():
        return buf_.read_float32_le(pos_ + 4)
    def z():
        return buf_.read_float32_le(pos_ + 8)

def CreateVec3(b_:flatbuffers_builder, x:float, y:float, z:float):
    b_.Prep(4, 12)
    b_.PrependFloat32(z)
    b_.PrependFloat32(y)
    b_.PrependFloat32(x)
    return b_.Offset()

class Monster : flatbuffers_handle
    def pos():
        let o = buf_.flatbuffers_field_struct(pos_, 4)
        return if o: MyGame_Sample_Vec3 { buf_, o } else: nil
    def mana():
        return buf_.flatbuffers_field_int16(pos_, 6, 150)
    def hp():
        return buf_.flatbuffers_field_int16(pos_, 8, 100)
    def name():
        return buf_.flatbuffers_field_string(pos_, 10)
    def inventory(i:int):
        return buf_.read_int8_le(buf_.flatbuffers_field_vector(pos_, 14) + i * 1)
    def inventory_length():
        return buf_.flatbuffers_field_vector_len(pos_, 14)
    def color():
        return Color(buf_.flatbuffers_field_int8(pos_, 16, 2))
    def weapons(i:int):
        return MyGame_Sample_Weapon { buf_, buf_.flatbuffers_indirect(buf_.flatbuffers_field_vector(pos_, 18) + i * 4) }
    def weapons_length():
        return buf_.flatbuffers_field_vector_len(pos_, 18)
    def equipped_type():
        return Equipment(buf_.flatbuffers_field_int8(pos_, 20, 0))
    def equipped_as_Weapon():
        return MyGame_Sample_Weapon { buf_, buf_.flatbuffers_field_table(pos_, 22) }
    def path(i:int):
        return MyGame_Sample_Vec3 { buf_, buf_.flatbuffers_field_vector(pos_, 24) + i * 12 }
    def path_length():
        return buf_.flatbuffers_field_vector_len(pos_, 24)

def GetRootAsMonster(buf:string): return Monster { buf, buf.flatbuffers_indirect(0) }

struct MonsterBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(11)
        return this
    def add_pos(pos:flatbuffers_offset):
        b_.PrependStructSlot(0, pos)
        return this
    def add_mana(mana:int):
        b_.PrependInt16Slot(1, mana, 150)
        return this
    def add_hp(hp:int):
        b_.PrependInt16Slot(2, hp, 100)
        return this
    def add_name(name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(3, name)
        return this
    def add_inventory(inventory:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(5, inventory)
        return this
    def add_color(color:Color):
        b_.PrependInt8Slot(6, color, 2)
        return this
    def add_weapons(weapons:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(7, weapons)
        return this
    def add_equipped_type(equipped_type:Equipment):
        b_.PrependUint8Slot(8, equipped_type, 0)
        return this
    def add_equipped(equipped:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(9, equipped)
        return this
    def add_path(path:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(10, path)
        return this
    def end():
        return b_.EndObject()

def MonsterStartInventoryVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(1, n_, 1)
def MonsterCreateInventoryVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def MonsterStartWeaponsVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def MonsterCreateWeaponsVector(b_:flatbuffers_builder, v_:[flatbuffers_offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MonsterStartPathVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(12, n_, 4)

class Weapon : flatbuffers_handle
    def name():
        return buf_.flatbuffers_field_string(pos_, 4)
    def damage():
        return buf_.flatbuffers_field_int16(pos_, 6, 0)

def GetRootAsWeapon(buf:string): return Weapon { buf, buf.flatbuffers_indirect(0) }

struct WeaponBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(2)
        return this
    def add_name(name:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, name)
        return this
    def add_damage(damage:int):
        b_.PrependInt16Slot(1, damage, 0)
        return this
    def end():
        return b_.EndObject()

